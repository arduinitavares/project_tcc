# The Real State Management Fix - November 30, 2025

## TL;DR

**Problem**: Memory loss between turns - agent kept asking same questions.

**Wrong diagnosis**: Thought we needed to capture tool responses for manual state persistence.

**Real issue**: We were **injecting state into user messages** which broke the Orchestrator's ability to read from chat history.

**Solution**: **Just pass raw user input.** ADK + Orchestrator handle state automatically via conversation history.

---

## The Three-Layer Architecture

1. **ADK Session** - Conversation history (automatic)
2. **Chat History** - Orchestrator reads previous tool outputs (automatic)  
3. **Business DB** - Final persistence via `save_vision_tool` (manual, on confirmation)

---

## What We Fixed

### BEFORE (Broken)
```python
# We wrapped user input with state tags
prompt_with_state = f"""
<prior_vision_state>{prior_state_str}</prior_vision_state>
<user_raw_text>{user_input}</user_raw_text>
"""
message = types.Content(role="user", parts=[types.Part(text=prompt_with_state)])
```

**Why it broke:**
- Orchestrator couldn't find tool outputs in wrapped messages
- Orchestrator's instructions say to read from "chat history"
- Our wrapping put data in wrong place
- Orchestrator saw `NO_HISTORY` every time

### AFTER (Fixed)
```python
# Just pass the user's raw input!
message = types.Content(role="user", parts=[types.Part(text=user_input)])
```

**Why it works:**
- ADK Runner maintains conversation history automatically
- Orchestrator reads previous `product_vision_tool` outputs from chat
- Orchestrator extracts state and passes to next tool call
- No manual intervention needed!

---

## Trust The Framework

The Orchestrator's instructions literally say:

> `prior_vision_state`: **COPY** the entire JSON string from the *previous* `product_vision_tool` output found in the **chat history**.

We should have listened! The chat history IS the state.
